# Инфраструктурные заметки для проектов по инженерии ИИ

Этот файл — набор коротких заметок про инфраструктуру, которые:

- не являются жёсткими требованиями курса;
- но помогают сделать проект менее хрупким и более «похожим на взрослый».

Фокус: **локальная разработка + простое развёртывание** (Docker/venv), конфиги, секреты, логи, сеть и минимальный CI.

---

## 1. Зачем думать про инфраструктуру

Инженерия ИИ — это не только «написать модель».  
Проект живёт в реальном окружении:

- его надо где-то запускать (локально, на сервере, в Docker);
- он должен уметь брать конфиги и секреты без хардкода;
- он должен писать логи и не падать молча;
- его должно быть можно проверить и запустить не только автору.

Базовые инфраструктурные практики:

- уменьшают «магии» и случайности;
- повышают воспроизводимость;
- готовят к промышленной разработке без перегруза терминологией.

---

## 2. Локальное окружение vs Docker

### 2.1. Локальное окружение (venv)

Минимум:

- `python -m venv .venv`
- `pip install -r requirements.txt`

Плюсы:

- быстро стартовать;
- удобно для ноутбуков и экспериментов.

Минусы:

- «работает у меня» ≠ «запустится у проверяющего» (разные ОС, версии библиотек);
- сложнее гарантировать одинаковое окружение.

### 2.2. Docker-контейнер

Идея:

- собрать образ, где:
  - фиксирована версия Python;
  - поставлены все зависимости;
  - прописан запуск сервиса;
- на любой машине с Docker сервис запускается одинаково.

Типичный паттерн для проекта:

- в корне `Dockerfile`;
- опционально `docker-compose.yml` для:
  - сервиса;
  - базы данных;
  - вспомогательных компонентов (например, локальный MinIO или очередь).

Для курсового проекта достаточно:

- одного контейнера с API-сервисом и моделью;
- чёткой инструкции «как собрать и запустить».

---

## 3. Конфигурация и секреты

### 3.1. Конфиги

Никогда не зашивай в код:

- порты;
- пути к данным;
- URL внешних сервисов.

Вместо этого:

- `configs/` с `.yaml`/`.json` конфигами;
- или чтение настроек из переменных окружения.

Пример идеи:

- `configs/config.yaml`:
  - параметры модели;
  - путь к файлам;
  - настройки API (порт, логирование).

### 3.2. Секреты

Жёсткое правило: **секреты не лежат в Git**.

Секреты — это:

- пароли к БД;
- API-токены;
- ключи доступа к облакам.

Минимальный паттерн:

- файл `.env.example` в репозитории:
  - перечисляет, какие переменные нужны;
- реальный `.env`:
  - создаётся локально;
  - добавлен в `.gitignore`;
  - не коммитится.

Вывод: конфиги и секреты — это разные сущности, их лучше не смешивать.

---

## 4. Логи и минимальная наблюдаемость

### 4.1. Логи вместо «тихой смерти»

Сервис ИИ должен:

- логировать старты и остановки;
- писать ошибки и исключения;
- логировать ключевые действия (`/predict`, обработка запросов).

На старте достаточно:

- логов в stdout (чтобы Docker/система их подхватывали);
- уровней логов (`INFO`, `WARNING`, `ERROR`).

Когда что-то идёт не так:

- в логах должна быть возможность понять «что» и «когда»;
- сообщение «что-то сломалось» без контекста — не лог.

### 4.2. Health-check

Простой, но важный endpoint `/health`:

- даёт 200 OK, если сервис жив и готов обработать запросы;
- может проверять:
  - что модель загружена;
  - что критичные зависимости доступны.

Даже в учебном проекте `/health` помогает:

- проверять, что сервис корректно поднялся;
- использовать его в тестах и демонстрациях.

---

## 5. Сеть, порты и «localhost»

### 5.1. Адреса

Часто встречающиеся адреса:

- `127.0.0.1` или `localhost` — «эта же машина» (только локальный доступ);
- `0.0.0.0` — «слушать на всех интерфейсах» (нужно для Docker и внешнего доступа).

Для локальной разработки:

- сервис обычно слушает `0.0.0.0:8000` внутри контейнера;
- снаружи доступ может быть, например, по `localhost:8000`.

### 5.2. Порты

Порты — номера «дверей» для сервисов:

- 8000, 8080 — типичные порты для тестовых HTTP-сервисов;
- важно не запускать два сервиса на одном порту одновременно.

Если `address already in use`:

- значит порт занят;
- или убираешь старый процесс;
- или меняешь порт.

---

## 6. Файлы, тома и работа с данными

### 6.1. Данные и контейнеры

Docker-контейнер:

- сам по себе **не хранит данные надёжно**;
- при пересборке/перезапуске содержимое может пропасть.

Для работы с данными:

- учебные/маленькие датасеты — можно копировать в образ;
- результаты/модели/артефакты — лучше монтировать через volumes.

В учебном проекте:

- важно хотя бы понимать разницу:
  - «файл внутри контейнера»;
  - «файл на хосте, примонтированный внутрь».

### 6.2. Папки в проекте

Структура наподобие:

```text
project/
  data/
  models/
  notebooks/
  src/
  configs/
  experiments/
```

помогает:

- не валить всё в одну кучу;
- сразу понимать, где что лежит;
- настраивать Docker/скрипты под конкретные папки.

---

## 7. Минимальный CI (Continuous Integration)

Даже для учебного проекта полезно:

- чтобы при каждом push’е в репозиторий:

  - проходили тесты;
  - хотя бы проверялась сборка сервиса.

Типичный вариант:

- GitHub Actions (файл `.github/workflows/...yml`);
- pipeline, который:

  - ставит Python;
  - устанавливает зависимости;
  - запускает `pytest` или хотя бы `python -m compileall`/линтер.

Зачем это нужно:

- чтобы не приехать на защиту с проектом, который вообще не запускается;
- чтобы автоматически ловить грубые ошибки (битый импорт, опечатки).

---

## 8. Инфраструктура и безопасность (по верхам)

Даже в учебных проектах важно:

- не светить секреты в логах и ответах API;
- не возвращать дампы стэктрейсов пользователю;
- не отдавать наружу лишние endpoints для отладки;
- помнить про ограничения по данным (особенно, если они не полностью synthetic/opensource).

В продакшене к этому добавляются:

- контроль доступа;
- сетевые ограничения;
- аудит действий;
- соответствие регуляторике.

В курсовом проекте достаточно:

- аккуратной работы с секретами;
- осторожного отношения к логам и ошибкам;
- понимания, что «локально на ноутбуке» и «в продакшене» — разные миры.

---

## 9. Мини-чеклист по инфраструктуре для сквозного проекта

Перед защитой проекта задай себе вопросы:

1. Можно ли **одним-двумя шагами** поднять сервис (venv или Docker) по инструкции в `project/README.md`?
2. Используешь ли ты какие-то **конфиги**, а не всё в хардкоде?
3. Хранятся ли секреты **вне Git** (через `.env`, переменные окружения)?
4. Есть ли **логи** и `/health`, чтобы понять, жив ли сервис?
5. Понимаешь ли ты, **на каком порту и на каком адресе** работает твой сервис?
6. Есть ли хоть какая-то **автоматическая проверка** (тесты/CI), что проект не сломан?

Если на большинство вопросов можно ответить «да» — у тебя более чем приличный инфраструктурный уровень для курсового проекта по инженерии ИИ.

---
