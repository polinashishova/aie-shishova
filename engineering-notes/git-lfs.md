# Git LFS для курса «Инженерия Искусственного Интеллекта»

Эта заметка про то:

- что такое Git LFS и зачем он нужен;
- какие файлы **имеет смысл** класть в LFS в рамках курса;
- как его настроить (минимальный сценарий);
- какие есть ограничения и типичные грабли.

---

## 1. Зачем вообще Git LFS

Обычный Git плохо работает с:

- **большими файлами** (десятки/сотни мегабайт и больше);
- **бинарниками**, которые часто меняются:
  - веса моделей (`.pt`, `.pth`, `.bin`);
  - большие чекпоинты;
  - архивы данных (`.zip`, `.tar.gz`);
  - изображения/видео в большом количестве.

Проблемы:

- репозиторий разрастается до гигабайтов;
- каждый клон тянет всю историю больших файлов;
- GitHub может начать ругаться на размер репозитория и отдельных файлов.

**Git LFS** (Large File Storage):

- хранит сами большие файлы отдельно от обычного Git-хранилища;
- в истории Git остаются маленькие «указатели» (текстовые ссылки на большие объекты);
- клон репозитория скачивает только нужные версии файлов через LFS.

---

## 2. Когда Git LFS уместен в курсовых репозиториях

Для курса «Инженерия ИИ» Git LFS может понадобиться, если:

- в проекте появляются **обученные веса модели** размером десятки мегабайт и больше;
- ты хочешь положить в репозиторий **артефакты**:
  - «этот конкретный чекпоинт модели, который мы защищаем»;
  - подготовленные эмбеддинги, если они большие;
- есть **один–два средних датасета** (на сотни мегабайт), без которых проект теряет смысл.

Хороший сигнал «надо подумать про LFS»:

- GitHub ругается на размер файла (>100 МБ);
- `git push` становится заметно медленным из-за пары больших файлов;
- репозиторий внезапно стал весить сотни мегабайт, хотя кода не так много.

---

## 3. Когда Git LFS НЕ решает задачу

Git LFS **не превращает** Git в хранилище терабайт:

- у GitHub есть лимиты на объём LFS-хранилища и трафик;
- LFS всё равно тянется при клонировании/чекауте нужных файлов.

Не стоит использовать Git LFS для:

- реально больших производственных датасетов (гигабайты и выше);
- «сырых» данных, которые можно скачать из открытого источника по скрипту (лучше положить скрипт);
- редкого артефакта, который можно держать в отдельном объектном хранилище или на диске и загружать вручную.

Для курса обычно достаточно:

- небольших учебных датасетов **в обычном Git**;
- крупных или производственных датасетов — **внешними ссылками/скриптами**;
- Git LFS — только для ограниченного числа важных артефактов (модель, эмбеддинги и т.п.).

---

## 4. Базовая настройка Git LFS

### 4.1. Установка Git LFS

Устанавливается **на машину**, а не в репозиторий.

Примеры (зависит от ОС, пакетного менеджера):

- Linux: через `apt`, `dnf`, `pacman` и т.п.;
- macOS: через `brew install git-lfs`;
- Windows: инсталлятор с сайта или через пакетный менеджер.

Проверка:

```bash
git lfs version
````

Если видишь версию — всё ок.

Затем один раз (глобальная инициализация):

```bash
git lfs install
```

---

### 4.2. Подключение LFS к конкретным типам файлов

В корне репозитория:

```bash
git lfs track "*.pt"
git lfs track "*.pth"
git lfs track "*.bin"
```

Git создаст/обновит файл `.gitattributes`:

```text
*.pt  filter=lfs diff=lfs merge=lfs -text
*.pth filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text
```

**Важно:** после этого:

- сам `.gitattributes` нужно добавить в обычный Git:

```bash
git add .gitattributes
git commit -m "Настроил Git LFS для весов моделей"
```

- все новые файлы с такими расширениями будут автоматически попадать в LFS при `git add`.

---

## 5. Типичный рабочий цикл с LFS

После настройки `track` для нужных типов файлов:

1. Кладёшь, например, обученную модель:

    ```bash
    ls project/models/
    # model_final.pt
    ```

2. Добавляешь в Git (обычно вместе с кодом):

    ```bash
    git add project/models/model_final.pt
    git commit -m "Добавил обученную модель"
    git push
    ```

3. Git:

- в обычную историю коммита кладёт маленький «указатель»;
- сам большой файл отправляет в LFS-хранилище (на GitHub и т.п.).

При `git clone` + `git lfs pull` на другой машине:

- подтянется указатель;
- Git LFS докачает сам файл из LFS.

---

## 6. Как понять, какие файлы уже в LFS

Команды:

```bash
git lfs ls-files        # показывает файлы, которые отслеживаются LFS
```

Вывод будет примерно:

```text
SHA-256 * project/models/model_final.pt
```

Это значит, что файл хранится в LFS, а в Git — текстовый pointer.

---

## 7. Потенциальные грабли и как их обходить

### 7.1. Большие файлы уже закоммичены без LFS

Классическая история:

- сначала закоммитили `model.pt` обычным Git;
- потом вспомнили про LFS и сделали `git lfs track`.

В результате:

- **в истории** репо модель уже лежит как большой бинарник;
- Git LFS начнёт отслеживать только **новые версии**.

Чтобы не плодить такие ситуации:

- **решать про LFS заранее**, как только понимаешь, что файл может быть тяжёлым;
- если уже поздно — можно переписать историю (`git filter-repo`/`git filter-branch`), но это тяжело и не для курса.

### 7.2. Коллега/проверяющий без Git LFS

Если на машине нет Git LFS, при `git clone`:

- будут подтянуты только текстовые «указатели»;
- реальные файлы не скачаются.

Решение:

1. Установить Git LFS и выполнить:

   ```bash
   git lfs install
   git lfs pull
   ```

2. Либо использовать графический клиент/IDE, которые умеют Git LFS из коробки.

### 7.3. Переполнение лимитов

Если активно пушить тяжёлые файлы/версии:

- можно упереться в лимиты LFS-хранилища и трафика на GitHub;
- репозиторий может перестать принимать push’и LFS-объектов.

Для учебных проектов разумно:

- не хранить десятки версий огромных моделей;
- оставлять в LFS **1–2 финальные версии**, старые — чистить вручную при необходимости.

---

## 8. Git LFS vs DVC и прочие системы версионирования данных

Git LFS:

- хорошо подходит для **нескольких важных больших файлов**;
- упрощает хранение модельных весов/чекпоинтов рядом с кодом;
- почти прозрачен для пользователя (немного другой push/pull).

DVC и аналоги:

- заточены под полноценное версионирование данных и моделей;
- умеют хранить артефакты в разных бекендах (S3, on-prem и т.д.);
- более гибкие, но сложнее в настройке.

Для курса «Инженерия ИИ»:

- **Git LFS** — минимальный уровень для аккуратного обращения с большими бинарниками;
- **DVC/аналог** — тема для продвинутых проектов и отдельных лекций/семинаров.

---

## 9. Мини-чеклист: нужно ли мне Git LFS в курсовом проекте?

Задай себе несколько вопросов:

1. Есть ли в проекте файлы **>50–100 МБ**, которые хочется держать в репозитории?
2. Это:

   - веса модели;
   - компактный учебный датасет;
   - важный артефакт (эмбеддинги, индекс и т.п.), без которого проект не воспроизводится?
3. Ожидается ли **небольшое число версий** этих файлов (1–3), а не десятки?
4. Готов ли ты установить Git LFS и следовать базовым правилам?

Если на большинство вопросов ответ «да»:

- имеет смысл настроить Git LFS для конкретных типов файлов: `*.pt`, `*.bin`, `*.pkl` и т.п.;
- добавить `.gitattributes` в репозиторий;
- аккуратно следить, чтобы большие файлы сразу шли через LFS.

Если же:

- датасеты огромные;
- их можно скачивать из открытых источников;
- веса моделей не критично хранить в Git (их легко восстановить);

то для курса достаточно:

- **не класть** такие файлы в репозиторий;
- делать скрипты/инструкции по скачиванию и восстановлению.

Git LFS — это не обязательная часть каждого проекта, но полезный инструмент, когда нужно аккуратно обращаться с несколькими тяжёлыми файлами в учебном ИИ-репозитории.

---
